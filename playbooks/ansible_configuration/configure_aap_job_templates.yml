---
# Consolidated playbook for configuring AAP Controller job templates
# Synopsis: Automates creation/update of AAP Controller job templates, inventories, and surveys using Controller API with multi-auth and enhanced error handling.
# Improved error handling, authentication methods, and survey configuration
# Supports OAuth tokens, username/password, and environment variables

- name: Configure AAP Controller Job Templates
  hosts: localhost
  connection: local
  gather_facts: false
  
  vars:
    # Controller connection - can be overridden via extra-vars or controller_vars.yml
    controller_host: ""
    controller_oauthtoken: ""
    controller_username: ""
    controller_password: ""
    controller_verify_ssl: true
    
    # Organization and project
    organization_name: "Default"
    project_name: "AnsibleSatellite"
    
    # Inventory and credentials
    inventory_name: "Satellite Inventory"
    # Optional: Global credential (legacy single-credential behavior). Prefer per-template below.
    credential_name: ""
    # Optional: Per-purpose credentials (recommended)
    machine_credential_name: ""
    satellite_api_credential_name: ""
    execution_environment: ""

    # Automation toggles (new)
    auto_create_credentials: false  # When true, attempt creation of missing machine / satellite API credentials
    auto_retry_job_template_creation: true  # When true, retry job template creation after forced project resync if playbook not found
    project_sync_poll: true  # Poll project update endpoint until finished instead of blind sleep
    project_sync_timeout: 120  # Seconds maximum wait for project sync job to finish
    project_sync_poll_interval: 6  # Seconds between status checks

    # Credential creation inputs (used only if auto_create_credentials=true)
    machine_credential_username: "root"
    machine_credential_password: ""  # optional ssh password, prefer key injection separately
    satellite_api_credential_username: "admin"
    satellite_api_credential_password: ""  # if blank and surveys supply password, credential may be created without secret
    scm_credential_type: "Source Control"  # create if scm_credential_name provided & auto_create_credentials=true
    scm_credential_username: ""  # for HTTPS git; alternatively supply token as password
    scm_credential_password: ""  # token/password

    # Project source (used only if auto-create requested)
    project_scm_url: ""
    project_scm_branch: "main"
    auto_create_project: false
    auto_create_inventory: false
    scm_credential_name: ""

    # Preflight network diagnostics toggle
    auto_network_preflight: true
    normalize_controller_host: true  # Strip any accidental /api/... fragments from controller_host
    strip_known_api_prefixes: true   # Remove /api/controller/v2, /api/gateway/v1/... if user pasted full path
    auto_insecure_on_cert_failure: false  # If true, automatically flip controller_verify_ssl to false after CERT failure
    
    # Retry configuration
    api_retry_count: 3
    api_retry_delay: 5
    
    # Workflow configuration
    workflow_name: "Satellite Provisioning Pipeline"
    jt_push_name: "Push Provisioning Template"
    jt_associate_name: "Associate Template to OS"
    jt_params_name: "Set Foreman Parameters"
    jt_bulk_name: "Bulk Node Builder"
    
    # Job templates to create (aligned to actual playbooks in this repo)
    job_templates:
      - name: "Bulk Node Builder"
        description: "Survey-driven bulk creation of Satellite hosts"
        playbook: "playbooks/node_provisioning/bulk_node_builder.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Bulk Node Builder Survey"
          description: "Configure node count, naming, and resource settings"
          spec:
            - question_name: "How many nodes to create?"
              required: true
              type: "integer"
              variable: "node_count"
              min: 1
              max: 100
              default: 5
            - question_name: "Start slot (optional)"
              required: false
              type: "integer"
              variable: "start_slot"
              min: 1
              max: 999
            - question_name: "Node name prefix"
              required: true
              type: "text"
              variable: "node_prefix"
              default: "node"
            - question_name: "Shortname prefix (optional override)"
              required: false
              type: "text"
              variable: "shortname"
            - question_name: "Domain"
              required: true
              type: "text"
              variable: "domain"
              default: "prod.spg"
            - question_name: "Sequential mode (extend from highest)"
              required: true
              type: "multiplechoice"
              variable: "sequential_mode"
              choices: ["true","false"]
              default: "true"
            - question_name: "Zero padding (digits)"
              required: true
              type: "integer"
              variable: "number_padding"
              min: 1
              max: 6
              default: 3
            - question_name: "Build strategy"
              required: true
              type: "multiplechoice"
              variable: "build_strategy"
              choices: ["linear","free"]
              default: "linear"
            - question_name: "Serial batch size (0 = all)"
              required: true
              type: "integer"
              variable: "serial_batch"
              min: 0
              max: 500
              default: 0
            - question_name: "MAC address prefix"
              required: true
              type: "text"
              variable: "mac_address_prefix"
              default: "52:54:00:aa:bb"
            - question_name: "Randomize MAC last octet"
              required: true
              type: "multiplechoice"
              variable: "random_mac"
              choices: ["true","false"]
              default: "false"
            - question_name: "Satellite host (FQDN)"
              required: true
              type: "text"
              variable: "satellite_host"
              default: "satellite.prod.spg"
            - question_name: "Satellite user"
              required: true
              type: "text"
              variable: "satellite_user"
              default: "admin"
            - question_name: "Satellite password (leave blank to use env cred)"
              required: false
              type: "password"
              variable: "satellite_password"
            - question_name: "Operating System ID"
              required: false
              type: "integer"
              variable: "os_id"
              min: 1
              max: 999
              default: 1
            - question_name: "Hostgroup ID"
              required: false
              type: "integer"
              variable: "hostgroup_id"
              min: 1
              max: 999
              default: 1
            - question_name: "Subnet ID"
              required: false
              type: "integer"
              variable: "subnet_id"
              min: 1
              max: 999
              default: 1
            - question_name: "Location ID"
              required: false
              type: "integer"
              variable: "location_id"
              min: 1
              max: 999
              default: 2
            - question_name: "Organization ID"
              required: false
              type: "integer"
              variable: "organization_id"
              min: 1
              max: 999
              default: 1
            - question_name: "CSV export path (Controller local path)"
              required: false
              type: "text"
              variable: "export_path"

      - name: "Push Provisioning Template"
        description: "Create or update Foreman/Satellite provisioning template"
        playbook: "playbooks/node_provisioning/push_provisioning_template.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Provisioning Template Survey"
          description: "Satellite credentials and template parameters"
          spec:
            - question_name: "Satellite URL"
              required: true
              type: "text"
              variable: "satellite_url"
              default: "https://satellite.prod.spg"
            - question_name: "Satellite username"
              required: true
              type: "text"
              variable: "satellite_username"
              default: "admin"
            - question_name: "Satellite password (leave blank to use env cred)"
              required: false
              type: "password"
              variable: "satellite_password"
            - question_name: "Template name"
              required: true
              type: "text"
              variable: "template_name"
              default: "RHEL 9.7 x86_64 Post-Kickstart Default"
            - question_name: "Template file path"
              required: true
              type: "text"
              variable: "template_file"
              default: "playbooks/node_provisioning/templates/RHEL_9.7_x86_64_post_kickstart_default.erb"

      - name: "Associate Template to OS"
        description: "Associate provisioning template to RHEL OS as default"
        playbook: "playbooks/node_provisioning/associate_template_to_os.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Associate Template Survey"
          description: "Satellite credentials and OS version"
          spec:
            - question_name: "Satellite URL"
              required: true
              type: "text"
              variable: "satellite_url"
              default: "https://satellite.prod.spg"
            - question_name: "Satellite username"
              required: true
              type: "text"
              variable: "satellite_username"
              default: "admin"
            - question_name: "Satellite password (leave blank to use env cred)"
              required: false
              type: "password"
              variable: "satellite_password"
            - question_name: "Template name"
              required: true
              type: "text"
              variable: "template_name"
              default: "RHEL 9.7 x86_64 Post-Kickstart Default"
            - question_name: "RHEL major version"
              required: true
              type: "integer"
              variable: "os_major"
              min: 7
              max: 10
              default: 9
            - question_name: "RHEL minor version"
              required: true
              type: "integer"
              variable: "os_minor"
              min: 0
              max: 99
              default: 7

      - name: "Set Foreman Parameters"
        description: "Create or update Foreman global parameters for %post logic"
        playbook: "playbooks/node_provisioning/set_foreman_parameters.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Foreman Parameters Survey"
          description: "Admin credentials and provisioning flags"
          spec:
            - question_name: "Satellite URL"
              required: true
              type: "text"
              variable: "satellite_url"
              default: "https://satellite.prod.spg"
            - question_name: "Satellite username"
              required: true
              type: "text"
              variable: "satellite_username"
              default: "admin"
            - question_name: "Satellite password (leave blank to use env cred)"
              required: false
              type: "password"
              variable: "satellite_password"
            - question_name: "Admin user"
              required: true
              type: "text"
              variable: "admin_user"
              default: "admin"
            - question_name: "Admin password"
              required: true
              type: "password"
              variable: "admin_password"
              default: "r3dh4t7!"
            - question_name: "Activation keys (e.g. 9:RHEL9-AK)"
              required: true
              type: "text"
              variable: "activation_keys"
              default: "9:RHEL9-AK"
            - question_name: "Enable package update in %post"
              required: true
              type: "multiplechoice"
              variable: "ks_enable_updates"
              choices: ["true","false"]
              default: "true"

      - name: "Verify Post Install Summary"
        description: "Wait for SSH and verify /root/post-install-summary.txt on new node"
        playbook: "playbooks/node_provisioning/verify_post_install_summary.yml"
        survey_enabled: true
        credential_names:
          - "{{ machine_credential_name }}"
        survey_spec:
          name: "Verify Post Install Survey"
          description: "Target host and SSH user"
          spec:
            - question_name: "Target host (FQDN or IP)"
              required: true
              type: "text"
              variable: "target_host"
            - question_name: "SSH user"
              required: true
              type: "text"
              variable: "ssh_user"
              default: "root"

      - name: "PXE Boot Troubleshoot"
        description: "Diagnostics and fixes for PXE boot issues (requires KVM host inventory)"
        playbook: "playbooks/node_provisioning/pxe_boot_troubleshoot.yml"
        survey_enabled: true
        credential_names:
          - "{{ machine_credential_name }}"
        survey_spec:
          name: "PXE Troubleshoot Survey"
          description: "VM name and KVM URI"
          spec:
            - question_name: "Libvirt VM name"
              required: true
              type: "text"
              variable: "vm_name"
            - question_name: "KVM URI"
              required: false
              type: "text"
              variable: "kvm_uri"
              default: "qemu:///system"

      - name: "Satellite Configuration Manager"
        description: "Compute profiles, defaults discovery, and PXE template fixes"
        playbook: "playbooks/satellite_configuration/satellite_configuration_manager.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Satellite Config Survey"
          description: "Select operation and related parameters"
          spec:
            - question_name: "Operation"
              required: true
              type: "multiplechoice"
              variable: "operation"
              choices: ["compute_profiles","discover_defaults","fix_pxe_templates"]
              default: "compute_profiles"
            - question_name: "Compute resource ID"
              required: false
              type: "integer"
              variable: "compute_resource_id"
              min: 1
              max: 999
              default: 1
            - question_name: "PXE bridge"
              required: false
              type: "text"
              variable: "pxe_bridge"
              default: "virbr1"
            - question_name: "PXE network"
              required: false
              type: "text"
              variable: "pxe_network"
              default: "internal"
            - question_name: "Subnet ID"
              required: false
              type: "integer"
              variable: "subnet_id"
              min: 1
              max: 999
              default: 1

      - name: "Satellite Email Notifications"
        description: "Configure SMTP relay or send/verify test emails from Satellite"
        playbook: "playbooks/satellite_configuration/satellite_email_notifications.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Email Notifications Survey"
          description: "SMTP relay and test controls"
          spec:
            - question_name: "Operation"
              required: true
              type: "multiplechoice"
              variable: "operation"
              choices: ["configure","send","verify"]
              default: "configure"
            - question_name: "SMTP relay host"
              required: true
              type: "text"
              variable: "smtp_host"
              default: "localhost"
            - question_name: "SMTP relay port"
              required: true
              type: "integer"
              variable: "smtp_port"
              min: 1
              max: 65535
              default: 587
            - question_name: "SMTP account"
              required: true
              type: "text"
              variable: "smtp_account"
              default: "admin@prod.spg"
            - question_name: "SMTP password (leave blank to use env)"
              required: false
              type: "password"
              variable: "smtp_account_password"
            - question_name: "Use TLS"
              required: true
              type: "multiplechoice"
              variable: "smtp_use_tls"
              choices: ["true","false"]
              default: "true"
            - question_name: "From email"
              required: false
              type: "text"
              variable: "smtp_from_email"
              default: "admin@prod.spg"
            - question_name: "Recipient emails (comma-separated)"
              required: false
              type: "text"
              variable: "smtp_to_emails"
              default: "admin@prod.spg"

      - name: "Satellite Health Monitoring"
        description: "Run health checks or backup configuration with retention"
        playbook: "playbooks/satellite_configuration/satellite_health_monitoring.yml"
        survey_enabled: true
        credential_names:
          - "{{ satellite_api_credential_name }}"
        survey_spec:
          name: "Health/Backup Survey"
          description: "Select operation and backup settings"
          spec:
            - question_name: "Operation"
              required: true
              type: "multiplechoice"
              variable: "operation"
              choices: ["health_check","backup"]
              default: "health_check"
            - question_name: "Backup root directory"
              required: false
              type: "text"
              variable: "backup_root"
              default: "/root/satellite-config-backups"
            - question_name: "Backup retention days"
              required: false
              type: "integer"
              variable: "backup_retention_days"
              min: 1
              max: 365
              default: 30

      - name: "Cleanup Orphaned Disks"
        description: "Remove orphaned VM libvirt disk volumes"
        playbook: "playbooks/libvirt_configuration/cleanup_orphaned_disks.yml"
        survey_enabled: true
        credential_names:
          - "{{ machine_credential_name }}"
        survey_spec:
          name: "Orphaned Disks Survey"
          description: "KVM host and domain filter"
          spec:
            - question_name: "KVM host (IP or name)"
              required: true
              type: "text"
              variable: "kvm_host"
              default: "10.168.0.1"
            - question_name: "Domain name pattern"
              required: true
              type: "text"
              variable: "domain_pattern"
              default: "prod.spg"

  pre_tasks:
    - name: Load controller_vars.yml if it exists
      block:
        - name: Check for controller_vars.yml
          ansible.builtin.stat:
            path: "{{ playbook_dir }}/controller_vars.yml"
          register: _controller_vars_file

        - name: Load controller variables from file
          ansible.builtin.include_vars:
            file: "{{ playbook_dir }}/controller_vars.yml"
          when: _controller_vars_file.stat.exists
      tags: always

    - name: Normalize authentication credentials
      ansible.builtin.set_fact:
        _controller_token: "{{ controller_oauthtoken | default(lookup('env', 'CONTROLLER_OAUTH_TOKEN'), true) | default('', true) }}"
        _controller_username: "{{ controller_username | default(lookup('env', 'CONTROLLER_USERNAME'), true) | default('', true) }}"
        _controller_password: "{{ controller_password | default(lookup('env', 'CONTROLLER_PASSWORD'), true) | default('', true) }}"
      no_log: true
      tags: always

    - name: Normalize controller_host (remove protocol path fragments)
      when: normalize_controller_host | bool
      block:
        - name: Capture raw controller_host
          ansible.builtin.set_fact:
            _controller_host_raw: "{{ controller_host }}"

        - name: Strip trailing slashes
          ansible.builtin.set_fact:
            controller_host: "{{ controller_host | regex_replace('/+$','') }}"

        - name: Remove embedded /api/... path if present
          ansible.builtin.set_fact:
            controller_host: "{{ controller_host | regex_replace('/api/.*$','') }}"
          when: strip_known_api_prefixes | bool and (controller_host is match('/api/') )

        - name: Ensure protocol present (default https if missing)
          ansible.builtin.set_fact:
            controller_host: "https://{{ controller_host }}"
          when: controller_host is not match('^https?://')

        - name: Strip double protocol (edge case user includes http twice)
          ansible.builtin.set_fact:
            controller_host: "{{ controller_host | regex_replace('^(https?://)+','https://') }}"

        - name: Display normalization result
          ansible.builtin.debug:
            msg: |
              Controller host normalized.
              Raw input: {{ _controller_host_raw }}
              Normalized: {{ controller_host }}
              (Paths like /api/controller/v2 automatically removed.)
      tags: always

    - name: Interactive credential prompt (if no auth provided)
      block:
        - name: Prompt for Controller username
          ansible.builtin.pause:
            prompt: "Enter AAP Controller username"
          register: _prompt_username
          when: _controller_token | length == 0 and _controller_username | length == 0

        - name: Prompt for Controller password
          ansible.builtin.pause:
            prompt: "Enter AAP Controller password"
            echo: false
          register: _prompt_password
          when: _controller_token | length == 0 and _controller_username | length == 0

        - name: Set prompted credentials
          ansible.builtin.set_fact:
            _controller_username: "{{ _prompt_username.user_input | default(_controller_username) }}"
            _controller_password: "{{ _prompt_password.user_input | default(_controller_password) }}"
          no_log: true
          when:
            - _controller_token | length == 0
            - _prompt_username.user_input is defined
      when: _controller_token | length == 0 and _controller_username | length == 0
      tags: always

    - name: Validate authentication method available
      ansible.builtin.assert:
        that:
          - _controller_token | length > 0 or (_controller_username | length > 0 and _controller_password | length > 0)
        fail_msg: |
          No valid authentication method provided.
          
          Provide one of:
          1. OAuth Token: -e controller_oauthtoken=TOKEN or export CONTROLLER_OAUTH_TOKEN=TOKEN
          2. Username/Password: -e controller_username=USER controller_password=PASS
          3. controller_vars.yml file in playbook directory
          4. Interactive prompt (run without credentials)
          
          To generate OAuth token in AAP:
          - Navigate to: https://{{ controller_host }}/#/users/<username>/tokens
          - Create new token with 'Write' scope
        success_msg: "Authentication credentials validated"
      tags: always

    - name: Validate required configuration
      ansible.builtin.assert:
        that:
          - controller_host | length > 0
          - organization_name | length > 0
          - project_name | length > 0
          - inventory_name | length > 0
        fail_msg: |
          Missing required configuration variables.
          Required: controller_host, organization_name, project_name, inventory_name
          
          Provide via:
          - Extra vars: -e controller_host=https://ansible.prod.spg
          - controller_vars.yml file (copy controller_vars.yml.example)
        success_msg: "Required configuration validated"
      tags: always

    - name: Preflight network diagnostics (DNS + TCP) before API probes
      when: auto_network_preflight | bool
      block:
        - name: Extract hostname portion (strip protocol)
          ansible.builtin.set_fact:
            _controller_host_base: "{{ controller_host | regex_replace('^https?://','') | regex_replace('/.*','') }}"

        - name: DNS lookup for Controller host
          ansible.builtin.command: getent hosts {{ _controller_host_base }}
          register: _dns_lookup
          changed_when: false
          failed_when: false

        - name: Set DNS resolution fact
          ansible.builtin.set_fact:
            _dns_resolved: "{{ _dns_lookup.rc == 0 }}"

        - name: Attempt TCP connectivity to 443 (short timeout)
          ansible.builtin.wait_for:
            host: "{{ _controller_host_base }}"
            port: 443
            timeout: 3
          register: _tcp_test
          failed_when: false
          changed_when: false

        - name: Summarize preflight diagnostics
          ansible.builtin.debug:
            msg: |
              Preflight network diagnostics:
              Host: {{ _controller_host_base }}
              DNS resolved: {{ _dns_resolved }}
              TCP 443 reachable: {{ (_tcp_test.elapsed is defined) | ternary('yes','no') }}
              Hint: If DNS=false or TCP=false, fix name resolution or firewall before continuing.

        - name: Abort early due to unresolved host
          ansible.builtin.fail:
            msg: |
              Controller host '{{ _controller_host_base }}' did not resolve (DNS lookup failed).
              Update controller_host extra-var to a reachable FQDN or add DNS/hosts entry.
          when: not _dns_resolved

        - name: Warn about TCP unreachable but continue (Controller may be down)
          ansible.builtin.debug:
            msg: "Controller host '{{ _controller_host_base }}' port 443 unreachable (timeout). Will attempt API probes anyway."
          when: _dns_resolved and (_tcp_test.elapsed is not defined)
      tags: always

    - name: Probe Controller API (controller/v2)
      ansible.builtin.uri:
        url: "{{ controller_host }}/api/controller/v2/ping/"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _api_ping_controller
      failed_when: false
      tags: always

    - name: Probe Controller API (gateway automation-controller)
      ansible.builtin.uri:
        url: "{{ controller_host }}/api/gateway/v1/automation-controller/v2/ping/"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _api_ping_gateway_ac
      failed_when: false
      tags: always

    - name: Probe Controller API (gateway controller)
      ansible.builtin.uri:
        url: "{{ controller_host }}/api/gateway/v1/controller/v2/ping/"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _api_ping_gateway_controller
      failed_when: false
      tags: always

    - name: Probe Controller API (v2)
      ansible.builtin.uri:
        url: "{{ controller_host }}/api/v2/ping/"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _api_ping_v2
      failed_when: false
      tags: always

    - name: Decide API base path
      ansible.builtin.set_fact:
        _api_base: >-
          {{
            '/api/controller/v2' if (_api_ping_controller.status | default(0)) == 200 else
            (
              '/api/gateway/v1/automation-controller/v2' if (_api_ping_gateway_ac.status | default(0)) == 200 else
              (
                '/api/gateway/v1/controller/v2' if (_api_ping_gateway_controller.status | default(0)) == 200 else
                (
                  '/api/v2' if (_api_ping_v2.status | default(0)) == 200 else ''
                )
              )
            )
          }}
      tags: always

    - name: Detect SSL certificate verification errors
      ansible.builtin.set_fact:
        _ssl_verify_error: >-
          {{
            ('CERTIFICATE_VERIFY_FAILED' in (_api_ping_controller.msg | default(''))) or
            ('CERTIFICATE_VERIFY_FAILED' in (_api_ping_gateway_ac.msg | default(''))) or
            ('CERTIFICATE_VERIFY_FAILED' in (_api_ping_gateway_controller.msg | default(''))) or
            ('CERTIFICATE_VERIFY_FAILED' in (_api_ping_v2.msg | default('')))
          }}
      tags: always

    - name: Auto-switch to insecure verification on cert failure
      when:
        - _api_base | length == 0
        - _ssl_verify_error | bool
        - auto_insecure_on_cert_failure | bool
        - controller_verify_ssl | bool
      block:
        - name: Log auto-switch warning
          ansible.builtin.debug:
            msg: |
              SSL certificate verification failed; auto_insecure_on_cert_failure=true so continuing with controller_verify_ssl=false.
              ORIGINAL host: {{ controller_host }}
              Consider installing CA bundle instead of disabling verification.

        - name: Disable SSL verification dynamically
          ansible.builtin.set_fact:
            controller_verify_ssl: false
      tags: always

    - name: Re-probe API endpoints without SSL verification (fallback)
      when: _api_base | length == 0 and controller_verify_ssl | bool and _ssl_verify_error | bool
      block:
        - name: Probe (insecure) Controller API (controller/v2)
          ansible.builtin.uri:
            url: "{{ controller_host }}/api/controller/v2/ping/"
            method: GET
            return_content: true
            status_code: 200
            validate_certs: false
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          register: _api_ping_controller_insecure
          failed_when: false

        - name: Probe (insecure) Controller API (gateway automation-controller)
          ansible.builtin.uri:
            url: "{{ controller_host }}/api/gateway/v1/automation-controller/v2/ping/"
            method: GET
            return_content: true
            status_code: 200
            validate_certs: false
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          register: _api_ping_gateway_ac_insecure
          failed_when: false

        - name: Probe (insecure) Controller API (gateway controller)
          ansible.builtin.uri:
            url: "{{ controller_host }}/api/gateway/v1/controller/v2/ping/"
            method: GET
            return_content: true
            status_code: 200
            validate_certs: false
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          register: _api_ping_gateway_controller_insecure
          failed_when: false

        - name: Probe (insecure) Controller API (v2)
          ansible.builtin.uri:
            url: "{{ controller_host }}/api/v2/ping/"
            method: GET
            return_content: true
            status_code: 200
            validate_certs: false
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          register: _api_ping_v2_insecure
          failed_when: false

        - name: Decide API base path (insecure)
          ansible.builtin.set_fact:
            _api_base_insecure: >-
              {{
                '/api/controller/v2' if (_api_ping_controller_insecure.status | default(0)) == 200 else
                (
                  '/api/gateway/v1/automation-controller/v2' if (_api_ping_gateway_ac_insecure.status | default(0)) == 200 else
                  (
                    '/api/gateway/v1/controller/v2' if (_api_ping_gateway_controller_insecure.status | default(0)) == 200 else
                    (
                      '/api/v2' if (_api_ping_v2_insecure.status | default(0)) == 200 else ''
                    )
                  )
                )
              }}
      tags: always

    - name: Abort with SSL guidance (endpoint reachable only without verification)
      when:
        - _api_base | length == 0
        - _api_base_insecure | default('') | length > 0
      ansible.builtin.fail:
        msg: |
          SSL certificate verification failed, but the Controller endpoint is reachable when SSL verification is disabled.

          Detected working base (insecure): {{ _api_base_insecure }}

          Fix options:
          1) Re-run with SSL verification disabled (lab/non-prod):
             -e controller_verify_ssl=false

          2) Install the proper CA chain and keep verification enabled (recommended):
             - Place your CA bundle on the control node and export REQUESTS_CA_BUNDLE=/path/to/ca-bundle.pem
             - Or import the enterprise CA into the system trust store

          3) Ensure your reverse proxy includes full certificate chain

          After fixing SSL, re-run this playbook.

    - name: Handle API connectivity issues
      block:
        - name: Display connectivity troubleshooting
          ansible.builtin.debug:
            msg: |
              Failed to connect to AAP Controller API
              
              Tried URLs:
              - {{ controller_host }}/api/controller/v2/ping/ -> Status: {{ _api_ping_controller.status | default('No response') }}
                Error: {{ _api_ping_controller.msg | default('Connection failed') }}
              - {{ controller_host }}/api/gateway/v1/automation-controller/v2/ping/ -> Status: {{ _api_ping_gateway_ac.status | default('No response') }}
                Error: {{ _api_ping_gateway_ac.msg | default('Connection failed') }}
              - {{ controller_host }}/api/gateway/v1/controller/v2/ping/ -> Status: {{ _api_ping_gateway_controller.status | default('No response') }}
                Error: {{ _api_ping_gateway_controller.msg | default('Connection failed') }}
              - {{ controller_host }}/api/v2/ping/ -> Status: {{ _api_ping_v2.status | default('No response') }}
                Error: {{ _api_ping_v2.msg | default('Connection failed') }}
              
              Troubleshooting:
              1. Verify controller_host URL is correct
              2. Check network connectivity: curl -k {{ controller_host }}/api/v2/ping/ (or /api/controller/v2/ping/)
              3. If using self-signed certs, set controller_verify_ssl: false
              4. Verify AAP services are running
              5. Check firewall rules allow HTTPS (443)

        - name: Fail with helpful message
          ansible.builtin.fail:
            msg: "Cannot proceed without AAP API connectivity. See troubleshooting above."
      when: _api_base | length == 0
      tags: always

    - name: Display API connectivity success
      ansible.builtin.debug:
        msg: "Successfully connected to AAP Controller: {{ controller_host }} (base: {{ _api_base }})"
      when: _api_base | length > 0
      tags: always

    # ========================================
    # Lookup Organization ID (needed for inventory queries)
    # ========================================
    - name: Query organization by name
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/organizations/?name={{ organization_name | urlencode }}"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _org_query
      tags: setup

    - name: Set organization id fact
      ansible.builtin.set_fact:
        _org_id: "{{ (_org_query.json.results | default([])) | first | default({}) | json_query('id') | default(0) }}"
      tags: setup

    - name: Fail if organization not found
      ansible.builtin.fail:
        msg: "Organization '{{ organization_name }}' not found on Controller."
      when: _org_id | int == 0
      tags: setup

    # ========================================
    # Ensure Project Exists (query + optional create)
    # ========================================
    - name: Query project existence
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/projects/?name={{ project_name | urlencode }}"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _project_query
      tags: setup

    - name: Set project existence fact
      ansible.builtin.set_fact:
        _project_exists: "{{ (_project_query.json.results | default([])) | length > 0 }}"
      tags: setup

    - name: Create project (SCM) if missing and auto_create enabled
      block:
        - name: Primary project creation (git)
          ansible.controller.project:
            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
            controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
            controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
            validate_certs: "{{ controller_verify_ssl }}"
            name: "{{ project_name }}"
            organization: "{{ organization_name }}"
            scm_type: git
            scm_url: "{{ project_scm_url }}"
            scm_branch: "{{ project_scm_branch }}"
            scm_update_on_launch: true
            scm_credential: "{{ scm_credential_name if scm_credential_name | length > 0 else omit }}"
            state: present
          register: _project_create
          when: project_scm_url | length > 0

        - name: Fallback project creation (manual, no SCM)
          ansible.controller.project:
            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
            controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
            controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
            validate_certs: "{{ controller_verify_ssl }}"
            name: "{{ project_name }}"
            organization: "{{ organization_name }}"
            scm_type: manual
            state: present
          register: _project_create_manual
          when: project_scm_url | length == 0
      rescue:
        - name: Capture project creation failure details
          ansible.builtin.debug:
            msg: |
              Project creation (git) failed.
              URL: {{ project_scm_url }} Branch: {{ project_scm_branch }}
              Error: {{ _project_create.msg | default('No message') }}
              Attempting manual project fallback...
          when: project_scm_url | length > 0
        - name: Manual fallback after git failure
          ansible.controller.project:
            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
            controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
            controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
            validate_certs: "{{ controller_verify_ssl }}"
            name: "{{ project_name }}"
            organization: "{{ organization_name }}"
            scm_type: manual
            state: present
          register: _project_create_manual_rescue
      when:
        - not _project_exists
        - auto_create_project
      tags: setup

    - name: Warn if project missing and not auto-created
      ansible.builtin.debug:
        msg: |
          Project '{{ project_name }}' not found and auto_create_project=false.
          Either create the Project manually in Controller pointing to the repo with playbooks,
          or re-run with -e auto_create_project=true -e project_scm_url=<git_url>.
      when:
        - not _project_exists
        - not auto_create_project
      tags: setup

    - name: Force fail if project still missing
      ansible.builtin.fail:
        msg: "Project '{{ project_name }}' required for job template creation but does not exist."
      when:
        - not _project_exists
        - (not auto_create_project) or (auto_create_project and (project_scm_url | length == 0))
      tags: setup

    # ========================================
    # Ensure Inventory Exists (query + optional create)
    # ========================================
    - name: Query inventory existence
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/inventories/?name={{ inventory_name | urlencode }}&organization={{ _org_id }}"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _inventory_query
      tags: setup

    - name: Set inventory existence fact
      ansible.builtin.set_fact:
        _inventory_exists: "{{ (_inventory_query.json.results | default([])) | length > 0 }}"
      tags: setup

    - name: Create inventory if missing and auto_create enabled
      ansible.controller.inventory:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        name: "{{ inventory_name }}"
        organization: "{{ organization_name }}"
        description: "Auto-created inventory for AnsibleSatellite templates"
        state: present
      when:
        - not _inventory_exists
        - auto_create_inventory
      register: _inventory_create
      tags: setup

    - name: Warn if inventory missing and not auto-created
      ansible.builtin.debug:
        msg: |
          Inventory '{{ inventory_name }}' not found and auto_create_inventory=false.
          Either create the Inventory manually in Controller or re-run with -e auto_create_inventory=true.
      when:
        - not _inventory_exists
        - not auto_create_inventory
      tags: setup

    - name: Force fail if inventory still missing
      ansible.builtin.fail:
        msg: "Inventory '{{ inventory_name }}' required for job template creation but does not exist."
      when:
        - not _inventory_exists
        - not auto_create_inventory
      tags: setup

    # ========================================
    # Credential & Execution Environment Discovery (Optional)
    # ========================================
    - name: Build unique credential name list
      ansible.builtin.set_fact:
        _all_credential_names: >-
          {{
            ([credential_name, machine_credential_name, satellite_api_credential_name, scm_credential_name] +
            (job_templates | map(attribute='credential_names') | flatten))
            | reject('equalto','') | reject('equalto', None) | list | unique
          }}
      tags: setup

    - name: Query credentials by name
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/credentials/?name={{ item | urlencode }}&organization={{ _org_id }}"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      loop: "{{ _all_credential_names }}"
      loop_control:
        label: "{{ item }}"
      register: _credential_queries
      when: _all_credential_names | length > 0
      tags: setup

    - name: Build credential id map
      ansible.builtin.set_fact:
        _credential_id_map: |
          {% set m = {} %}
          {% for r in _credential_queries.results | default([]) %}
          {%   set id = (r.json.results | default([])) | first | default({}) | json_query('id') | default(None) %}
          {%   set _ = m.update({ r.item: id }) %}
          {% endfor %}
          {{ m }}
      when: _all_credential_names | length > 0
      tags: setup

    - name: Determine missing credentials (for optional auto-create)
      ansible.builtin.set_fact:
        _missing_credentials: "{{ _credential_id_map | dict2items | selectattr('value','equalto', None) | map(attribute='key') | list }}"
      when: _credential_id_map is defined
      tags: setup

    - name: Auto-create missing credentials (machine, satellite API, SCM)
      when:
        - auto_create_credentials | bool
        - _missing_credentials | length > 0
      block:
        - name: Prepare auto-create credential specs list
          ansible.builtin.set_fact:
            _auto_credential_specs: |
              {% set specs = [] %}
              {% if machine_credential_name | length > 0 and machine_credential_name in _missing_credentials %}
              {%   set _ = specs.append({
                     'name': machine_credential_name,
                     'type': 'Machine',
                     'inputs': {
                       'username': machine_credential_username,
                       'password': machine_credential_password if machine_credential_password | length > 0 else None
                     }
                   }) %}
              {% endif %}
              {% if satellite_api_credential_name | length > 0 and satellite_api_credential_name in _missing_credentials %}
              {%   set _ = specs.append({
                     'name': satellite_api_credential_name,
                     'type': 'Machine',
                     'inputs': {
                       'username': satellite_api_credential_username,
                       'password': satellite_api_credential_password if satellite_api_credential_password | length > 0 else None
                     }
                   }) %}
              {% endif %}
              {% if scm_credential_name | length > 0 and scm_credential_name in _missing_credentials %}
              {%   set _ = specs.append({
                     'name': scm_credential_name,
                     'type': scm_credential_type,
                     'inputs': {
                       'username': scm_credential_username if scm_credential_username | length > 0 else None,
                       'password': scm_credential_password if scm_credential_password | length > 0 else None
                     }
                   }) %}
              {% endif %}
              {{ specs }}

        - name: Initialize credential results list
          when: _auto_credential_specs | length > 0
          ansible.builtin.set_fact:
            _auto_created_results: []

        - name: Primary credential create (all specs)
          when: _auto_credential_specs | length > 0
          ansible.controller.credential:
            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
            controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
            controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
            validate_certs: "{{ controller_verify_ssl }}"
            name: "{{ item.name }}"
            description: "Auto-created by configure_aap_job_templates.yml"
            organization: "{{ organization_name }}"
            credential_type: "{{ item.type }}"
            inputs:
              username: "{{ item.inputs.username | default('', true) }}"
              password: "{{ (item.inputs.password | default('', true)) if ((item.inputs.password | default('', true)) | length > 0) else omit }}"
            state: present
          loop: "{{ _auto_credential_specs }}"
          loop_control:
            label: "{{ item.name }}"
          register: _cred_primary_results
          failed_when: false

        - name: Fallback creation for failed non-Machine credentials
          when: _auto_credential_specs | length > 0
          ansible.controller.credential:
            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
            controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
            controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
            validate_certs: "{{ controller_verify_ssl }}"
            name: "{{ item.item.name }}"
            description: "Auto-created fallback (Machine) by configure_aap_job_templates.yml"
            organization: "{{ organization_name }}"
            credential_type: "Machine"
            inputs:
              username: "{{ item.item.inputs.username | default('', true) }}"
              password: "{{ (item.item.inputs.password | default('', true)) if ((item.item.inputs.password | default('', true)) | length > 0) else omit }}"
            state: present
          loop: "{{ _cred_primary_results.results | default([]) | selectattr('failed') | selectattr('item.type','ne','Machine') | list }}"
          loop_control:
            label: "{{ item.item.name }}"
          register: _cred_fallback_results
          failed_when: false

        - name: Aggregate credential creation outcome
          when: _auto_credential_specs | length > 0
          ansible.builtin.set_fact:
            _auto_created_results: |
              {% set final = [] %}
              {% for r in _cred_primary_results.results | default([]) %}
              {%   if r.failed and r.item.type != 'Machine' %}
              {%     set fb = (_cred_fallback_results.results | default([])) | selectattr('item.item.name','equalto', r.item.name) | list | first | default(r) %}
              {%     set _ = final.append(fb) %}
              {%   else %}
              {%     set _ = final.append(r) %}
              {%   endif %}
              {% endfor %}
              {{ final }}

        - name: Summarize credential creation failures
          ansible.builtin.debug:
            msg: |
              Credential creation summary:
              {% for r in _auto_created_results %}
              - {{ r.name | default(r.item.name | default('UNKNOWN')) }} : {{ 'FAILED' if r.failed | default(false) else 'ok' }}{% if r.failed %} (msg={{ r.msg | default('n/a') }}){% endif %}
              {% endfor %}
          when: _auto_created_results | length > 0

        - name: Set credential failure fact
          ansible.builtin.set_fact:
            _auto_credential_failures: "{{ _auto_created_results | selectattr('failed') | list }}"
          when: _auto_created_results | length > 0

        - name: Re-query credentials after auto-create
          ansible.builtin.uri:
            url: "{{ controller_host }}{{ _api_base }}/credentials/?name={{ item | urlencode }}&organization={{ _org_id }}"
            method: GET
            return_content: true
            status_code: 200
            validate_certs: "{{ controller_verify_ssl }}"
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          loop: "{{ _missing_credentials }}"
          register: _credential_requeries
          when: _missing_credentials | length > 0

        - name: Update credential id map after auto-create
          ansible.builtin.set_fact:
            _credential_id_map: |
              {% set m = _credential_id_map.copy() %}
              {% for r in _credential_requeries.results | default([]) %}
              {%   set id = (r.json.results | default([])) | first | default({}) | json_query('id') | default(None) %}
              {%   if id is not none %}{% set _ = m.update({ r.item: id }) %}{% endif %}
              {% endfor %}
              {{ m }}
          when: _credential_requeries is defined
      tags: setup

    - name: Warn about missing credentials
      ansible.builtin.debug:
        msg: |
          The following credential names were not found in organization '{{ organization_name }}':
          {% for n in _credential_id_map.keys() %}
          {%   if _credential_id_map[n] is none %}- {{ n }}{% endif %}
          {% endfor %}
          They will be skipped. Create credentials or adjust names if needed.
      when: _credential_id_map is defined and (_credential_id_map | dict2items | selectattr('value','equalto', None) | list | length) > 0
      tags: setup

    - name: Lookup execution environment by name (global)
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/execution_environments/?name={{ execution_environment | urlencode }}&organization={{ _org_id }}"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _ee_query
      when: execution_environment | length > 0
      failed_when: false
      tags: setup

    - name: Set execution environment id fact
      ansible.builtin.set_fact:
        _ee_id: "{{ (_ee_query.json.results | default([])) | first | default({}) | json_query('id') | default(None) }}"
      when: execution_environment | length > 0
      tags: setup

    - name: Warn if execution environment not found
      ansible.builtin.debug:
        msg: "Execution environment '{{ execution_environment }}' not found; templates will use default EE or project EE."
      when: execution_environment | length > 0 and _ee_id is not defined or _ee_id is none
      tags: setup

  tasks:
    - name: Derive project id (from query or creation)
      ansible.builtin.set_fact:
        _project_id: >-
          {{
            (_project_query.json.results | default([])) | first | default({}) | json_query('id')
            | default(
              _project_create.id | default(
                _project_create_manual.id | default(
                  _project_create_manual_rescue.id | default(None)
                )
              )
            )
          }}
      when: _project_exists or auto_create_project
      tags: setup

    - name: Trigger project sync (SCM) to ensure latest playbooks
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/projects/{{ _project_id }}/update/"
        method: POST
        status_code: 202
        return_content: true
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      register: _project_sync
      failed_when: false
      when:
        - _project_id is defined
        - _project_id is not none
        - project_scm_url | length > 0
      tags: setup

    - name: Pause briefly to allow project sync kickoff
      ansible.builtin.pause:
        seconds: 5
      when:
        - _project_id is defined
        - _project_id is not none
        - project_scm_url | length > 0
        - not project_sync_poll | bool
      tags: setup

    - name: Poll project sync status until complete (optional)
      when:
        - project_sync_poll | bool
        - _project_sync.json is defined
        - _project_sync.json.id is defined
        - project_scm_url | length > 0
      block:
        - name: Wait for project sync completion
          ansible.builtin.uri:
            url: "{{ controller_host }}{{ _api_base }}/project_updates/{{ _project_sync.json.id }}/"
            method: GET
            return_content: true
            status_code: 200
            validate_certs: "{{ controller_verify_ssl }}"
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          register: _sync_status
          until: _sync_status.json.finished is defined
          retries: "{{ (project_sync_timeout // project_sync_poll_interval) | int }}"
          delay: "{{ project_sync_poll_interval }}"
          failed_when: false

        - name: Warn if sync timeout reached
          ansible.builtin.debug:
            msg: "Project sync may still be running after timeout ({{ project_sync_timeout }}s); proceeding. Last status: {{ _sync_status.json.state | default('unknown') }}"
          when: _sync_status.json.finished is not defined
      tags: setup

    - name: Ensure ansible.controller collection is available
      block:
        - name: Check for ansible.controller collection
          ansible.builtin.command:
            cmd: ansible-galaxy collection list ansible.controller
          register: _collection_check
          changed_when: false
          failed_when: false

        - name: Install ansible.controller collection if missing
          ansible.builtin.command:
            cmd: ansible-galaxy collection install ansible.controller
          when: _collection_check.rc != 0
          changed_when: true
          become: false
      rescue:
        - name: Warn about collection installation
          ansible.builtin.debug:
            msg: |
              WARNING: ansible.controller collection not found and auto-install failed.
              Install manually: ansible-galaxy collection install ansible.controller
              Continuing, but job template tasks may fail.
      tags: setup

    - name: Create job templates
      ansible.controller.job_template:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        name: "{{ item.name }}"
        description: "{{ item.description }}"
        organization: "{{ organization_name }}"
        project: "{{ project_name }}"
        inventory: "{{ inventory_name }}"
        playbook: "{{ item.playbook }}"
        job_type: run
        execution_environment: "{{ _ee_id if (_ee_id is defined and _ee_id is not none) else (execution_environment if execution_environment | length > 0 else omit) }}"
        # Use credential IDs when available (preferred), else fall back to names
        credentials: >-
          {{
            (
              item.credential_names | default([]) | reject('equalto','') | reject('equalto', None) |
              map('extract', _credential_id_map | default({})) | reject('equalto', None) | list
            )
            if (_credential_id_map is defined and (item.credential_names | default([]) | reject('equalto','') | reject('equalto', None) | list | length) > 0)
            else (
              (item.credential_names | default([]) | reject('equalto','') | reject('equalto', None) | list)
              if (item.credential_names | default([]) | select('length') | list | length) > 0
              else ([credential_name] if credential_name | length > 0 else omit)
            )
          }}
        survey_enabled: "{{ item.survey_enabled | default(false) }}"
        survey_spec: "{{ item.survey_spec | default(omit) }}"
        ask_variables_on_launch: true
        ask_limit_on_launch: true
        state: present
      loop: "{{ job_templates }}"
      loop_control:
        label: "{{ item.name }}"
      register: _job_template_results
      failed_when: false
      tags: job_templates

    - name: Evaluate job template creation success
      ansible.builtin.set_fact:
        _jt_failures: "{{ _job_template_results.results | selectattr('failed') | list }}"
        _jt_successes: "{{ _job_template_results.results | rejectattr('failed') | list }}"
      tags: workflow

    - name: Retry job template creation for playbook-not-found failures (project resync fallback)
      when:
        - auto_retry_job_template_creation | bool
        - _jt_failures | length > 0
        - project_scm_url | length > 0
      block:
        - name: Identify retriable failures
          ansible.builtin.set_fact:
            _retriable_templates: "{{ _jt_failures | selectattr('msg','defined') | selectattr('msg','search','playbook') | map(attribute='item') | list }}"

        - name: Trigger forced project resync before retry
          ansible.builtin.uri:
            url: "{{ controller_host }}{{ _api_base }}/projects/{{ _project_id }}/update/"
            method: POST
            status_code: 202
            return_content: true
            validate_certs: "{{ controller_verify_ssl }}"
            headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token} if (_controller_token | length > 0) else omit }}"
            url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
            url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
            force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
          register: _forced_sync
          when: _retriable_templates | length > 0

        - name: Wait briefly after forced sync
          ansible.builtin.pause:
            seconds: 8
          when: _retriable_templates | length > 0

        - name: Second-pass creation of retriable job templates
          ansible.controller.job_template:
            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
            controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
            controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
            validate_certs: "{{ controller_verify_ssl }}"
            name: "{{ item.name }}"
            description: "{{ item.description }}"
            organization: "{{ organization_name }}"
            project: "{{ project_name }}"
            inventory: "{{ inventory_name }}"
            playbook: "{{ item.playbook }}"
            job_type: run
            execution_environment: "{{ _ee_id if (_ee_id is defined and _ee_id is not none) else (execution_environment if execution_environment | length > 0 else omit) }}"
            credentials: >-
              {{
                (
                  item.credential_names | default([]) | reject('equalto','') | reject('equalto', None) |
                  map('extract', _credential_id_map | default({})) | reject('equalto', None) | list
                )
                if (_credential_id_map is defined and (item.credential_names | default([]) | reject('equalto','') | reject('equalto', None) | list | length) > 0)
                else (
                  (item.credential_names | default([]) | reject('equalto','') | reject('equalto', None) | list)
                  if (item.credential_names | default([]) | select('length') | list | length) > 0
                  else ([credential_name] if credential_name | length > 0 else omit)
                )
              }}
            survey_enabled: "{{ item.survey_enabled | default(false) }}"
            survey_spec: "{{ item.survey_spec | default(omit) }}"
            ask_variables_on_launch: true
            ask_limit_on_launch: true
            state: present
          loop: "{{ _retriable_templates }}"
          loop_control:
            label: "{{ item.name }}"
          register: _jt_retry_results
          failed_when: false
          when: _retriable_templates | length > 0

        - name: Combine first-pass and retry results
          ansible.builtin.set_fact:
            _job_template_results_combined: "{{ (_job_template_results.results + (_jt_retry_results.results | default([]))) }}"
          when: _retriable_templates | length > 0

        - name: Recompute failure list after retry
          ansible.builtin.set_fact:
            _jt_failures_final: "{{ (_job_template_results_combined | default(_job_template_results.results)) | selectattr('failed') | list }}"
            _jt_successes_final: "{{ (_job_template_results_combined | default(_job_template_results.results)) | rejectattr('failed') | list }}"
          when: _retriable_templates | length > 0

    - name: Set final failure/success facts (no retry executed)
      ansible.builtin.set_fact:
        _jt_failures_final: "{{ _jt_failures }}"
        _jt_successes_final: "{{ _jt_successes }}"
      when: _jt_failures_final is not defined
      tags: workflow

    - name: Detailed debug for failed job templates (pre-abort)
      ansible.builtin.debug:
        msg: |
          Job template creation failures (raw results):
          {% for r in (_job_template_results.results + (_jt_retry_results.results | default([]))) %}
          {% if r.failed | default(false) %}
          ---
          Name: {{ r.item.name }}
          Playbook: {{ r.item.playbook }}
          Requested credential names: {{ r.item.credential_names | default([]) }}
          Credentials argument sent: {{ r.invocation.module_args.credentials | default('n/a') }}
          Message: {{ r.msg | default('no msg') }}
          Exception: {{ r.exception | default('n/a') }}
          Changed: {{ r.changed | default(false) }}
          Raw keys: {{ r.keys() | list }}
          {% endif %}
          {% endfor %}
      when: _jt_failures_final | length > 0
      tags: workflow

    - name: Abort workflow creation due to JT failures (after retry if enabled)
      ansible.builtin.fail:
        msg: |
          One or more job templates failed to create. Workflow will not be built.

          Failures:
          {% for r in _jt_failures_final %}
          - {{ r.item.name }}: {{ r.msg | default('Unknown error') }}
          {% endfor %}

          Hints:
          - Ensure Project '{{ project_name }}' is synced and contains playbook: {{ r.item.playbook | default('') }}
          - Ensure Inventory '{{ inventory_name }}' exists
          - Provide execution_environment / credentials if required by Controller policies
      when: _jt_failures_final | length > 0
      tags: workflow

    - name: Determine required job templates availability
      ansible.builtin.set_fact:
        _required_jt_names: ["{{ jt_push_name }}", "{{ jt_associate_name }}", "{{ jt_params_name }}", "{{ jt_bulk_name }}"]
        _jt_status_map: |
          {% set m = {} %}
          {% for r in _job_template_results.results %}
          {%   set _ = m.update({ r.item.name: { 'failed': r.failed | default(false), 'msg': r.msg | default(''), 'changed': r.changed | default(false) } }) %}
          {% endfor %}
          {{ m }}
      tags: workflow

    - name: List missing or failed required job templates
      ansible.builtin.debug:
        msg: |
          The following required job templates are missing or failed to create:
          {% for n in _required_jt_names %}
          {%   if (_jt_status_map.get(n) is not defined) or (_jt_status_map.get(n).failed | default(false)) %}
          - {{ n }}{% if _jt_status_map.get(n) is defined and _jt_status_map.get(n).msg %}: {{ _jt_status_map.get(n).msg }}{% endif %}
          {%   endif %}
          {% endfor %}
      when: _required_jt_names | select('in', _jt_status_map.keys() | list) | list | length < _required_jt_names | length
            or (_required_jt_names | select('equalto', None) | list | length > 0)
            or (_required_jt_names | select('in', _jt_status_map.keys() | list) | map('extract', _jt_status_map) | selectattr('failed') | list | length > 0)
      tags: workflow

    - name: Assert required job templates exist before creating workflow nodes
      ansible.builtin.assert:
        that:
          - (_required_jt_names | difference(_jt_status_map.keys() | list)) | length == 0
          - (_required_jt_names | map('extract', _jt_status_map) | selectattr('failed') | list | length) == 0
        fail_msg: |
          One or more required job templates were not created successfully. 
          Ensure the Controller Project ({{ project_name }}) and Inventory ({{ inventory_name }}) exist and are accessible.

          Missing or failed templates (name  message):
          {% for n in _required_jt_names %}
          {%   if (_jt_status_map.get(n) is not defined) or (_jt_status_map.get(n).failed | default(false)) %}
          - {{ n }}{% if _jt_status_map.get(n) is defined and _jt_status_map.get(n).msg %}: {{ _jt_status_map.get(n).msg }}{% endif %}
          {%   endif %}
          {% endfor %}

          Hints:
          - Confirm Project "{{ project_name }}" exists and points to this repo, with the correct default branch.
          - Confirm Inventory "{{ inventory_name }}" exists.
          - If job template creation failed due to credentials or EE, set credential_name/execution_environment variables.
      tags: workflow

    # ========================================
    # Build Job Template ID map directly from creation results
    # Fallback: query API only for missing IDs
    # ========================================
    - name: Build initial JT ID map from creation results
      ansible.builtin.set_fact:
        _jt_id_map: |
          {% set m = {} %}
          {% for r in _job_template_results.results %}
          {%   if r.item.name in _required_jt_names %}
          {%     set id = r.id | default(r.job_template.id | default(None)) %}
          {%     set _ = m.update({ r.item.name: id }) %}
          {%   endif %}
          {% endfor %}
          {{ m }}
      tags: workflow

    - name: Determine missing JT IDs after creation
      ansible.builtin.set_fact:
        _missing_jt_ids: "{{ _required_jt_names | difference(_jt_id_map.keys() | list) + (_jt_id_map | dict2items | selectattr('value','equalto', None) | map(attribute='key') | list) }}"
      tags: workflow

    - name: Query missing Job Template IDs (fallback API lookup)
      ansible.builtin.uri:
        url: "{{ controller_host }}{{ _api_base }}/job_templates/?name={{ item | urlencode }}&organization={{ _org_id }}"
        method: GET
        return_content: true
        status_code: 200
        validate_certs: "{{ controller_verify_ssl }}"
        headers: "{{ {'Authorization': 'Bearer ' ~ _controller_token, 'Content-Type': 'application/json'} if (_controller_token | length > 0) else omit }}"
        url_username: "{{ _controller_username if (_controller_token | length == 0) else omit }}"
        url_password: "{{ _controller_password if (_controller_token | length == 0) else omit }}"
        force_basic_auth: "{{ true if (_controller_token | length == 0) else omit }}"
      loop: "{{ _missing_jt_ids }}"
      loop_control:
        label: "{{ item }}"
      register: _jt_id_queries_fallback
      when: _missing_jt_ids | length > 0
      tags: workflow

    - name: Merge fallback JT IDs into map
      ansible.builtin.set_fact:
        _jt_id_map: |
          {% set m = _jt_id_map.copy() %}
          {% for r in _jt_id_queries_fallback.results | default([]) %}
          {%   set id = (r.json.results | default([])) | first | default({}) | json_query('id') | default(None) %}
          {%   set _ = m.update({ r.item: id }) %}
          {% endfor %}
          {{ m }}
      when: _missing_jt_ids | length > 0
      tags: workflow

    - name: Assert JT IDs resolved (post-fallback)
      ansible.builtin.assert:
        that:
          - (_required_jt_names | difference(_jt_id_map.keys() | list)) | length == 0
          - (_jt_id_map.values() | select('equalto', None) | list | length) == 0
        fail_msg: |
          Failed to resolve one or more Job Template IDs.
          Missing IDs for:
          {% for n in _required_jt_names %}
          {%   if (_jt_id_map.get(n) is not defined) or (_jt_id_map.get(n) is none) %}
          - {{ n }}
          {%   endif %}
          {% endfor %}
          Investigate Project sync or playbook path accuracy.
      tags: workflow

    # ========================================
    # Create/Update Workflow Job Template
    # ========================================
    - name: Create/Update workflow job template (skeleton)
      ansible.controller.workflow_job_template:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        name: "{{ workflow_name }}"
        organization: "{{ organization_name }}"
        ask_variables_on_launch: true
        survey_enabled: true
        survey_spec:
          name: "Provisioning Pipeline Survey"
          description: "Shared parameters for all steps"
          spec:
            - question_name: "Satellite URL"
              required: true
              type: "text"
              variable: "satellite_url"
              default: "https://satellite.prod.spg"
            - question_name: "Satellite username"
              required: true
              type: "text"
              variable: "satellite_username"
              default: "admin"
            - question_name: "Satellite password (leave blank to use env cred)"
              required: false
              type: "password"
              variable: "satellite_password"
            - question_name: "Template name"
              required: true
              type: "text"
              variable: "template_name"
              default: "RHEL 9.7 x86_64 Post-Kickstart Default"
            - question_name: "Template file path"
              required: true
              type: "text"
              variable: "template_file"
              default: "playbooks/node_provisioning/templates/RHEL_9.7_x86_64_post_kickstart_default.erb"
            - question_name: "RHEL major version"
              required: true
              type: "integer"
              variable: "os_major"
              min: 7
              max: 10
              default: 9
            - question_name: "RHEL minor version"
              required: true
              type: "integer"
              variable: "os_minor"
              min: 0
              max: 99
              default: 7
            - question_name: "Admin user"
              required: true
              type: "text"
              variable: "admin_user"
              default: "admin"
            - question_name: "Admin password"
              required: true
              type: "password"
              variable: "admin_password"
              default: "r3dh4t7!"
            - question_name: "Activation keys (e.g. 9:RHEL9-AK)"
              required: true
              type: "text"
              variable: "activation_keys"
              default: "9:RHEL9-AK"
            - question_name: "Enable package update in %post"
              required: true
              type: "multiplechoice"
              variable: "ks_enable_updates"
              choices: ["true","false"]
              default: "true"
            - question_name: "How many nodes to create?"
              required: true
              type: "integer"
              variable: "node_count"
              min: 1
              max: 100
              default: 5
            - question_name: "Node name prefix"
              required: true
              type: "text"
              variable: "node_prefix"
              default: "node"
            - question_name: "Domain"
              required: true
              type: "text"
              variable: "domain"
              default: "prod.spg"
            - question_name: "Sequential mode (extend from highest)"
              required: true
              type: "multiplechoice"
              variable: "sequential_mode"
              choices: ["true","false"]
              default: "true"
            - question_name: "Zero padding (digits)"
              required: true
              type: "integer"
              variable: "number_padding"
              min: 1
              max: 6
              default: 3
            - question_name: "Build strategy"
              required: true
              type: "multiplechoice"
              variable: "build_strategy"
              choices: ["linear","free"]
              default: "linear"
            - question_name: "Serial batch size (0 = all)"
              required: true
              type: "integer"
              variable: "serial_batch"
              min: 0
              max: 500
              default: 0
            - question_name: "MAC address prefix"
              required: true
              type: "text"
              variable: "mac_address_prefix"
              default: "52:54:00:aa:bb"
            - question_name: "Randomize MAC last octet"
              required: true
              type: "multiplechoice"
              variable: "random_mac"
              choices: ["true","false"]
              default: "false"
            - question_name: "CSV export path (Controller local path)"
              required: false
              type: "text"
              variable: "export_path"
      tags: workflow

    - name: Ensure workflow nodes exist - Push Template
      ansible.controller.workflow_job_template_node:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        workflow_job_template: "{{ workflow_name }}"
        unified_job_template: "{{ _jt_id_map[jt_push_name] }}"
        identifier: "push_template"
        state: present
      tags: workflow

    - name: Ensure workflow nodes exist - Associate Template to OS
      ansible.controller.workflow_job_template_node:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        workflow_job_template: "{{ workflow_name }}"
        unified_job_template: "{{ _jt_id_map[jt_associate_name] }}"
        identifier: "associate_os"
        state: present
      tags: workflow

    - name: Ensure workflow nodes exist - Set Foreman Parameters
      ansible.controller.workflow_job_template_node:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        workflow_job_template: "{{ workflow_name }}"
        unified_job_template: "{{ _jt_id_map[jt_params_name] }}"
        identifier: "foreman_params"
        state: present
      tags: workflow

    - name: Ensure workflow nodes exist - Bulk Node Builder
      ansible.controller.workflow_job_template_node:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        workflow_job_template: "{{ workflow_name }}"
        unified_job_template: "{{ _jt_id_map[jt_bulk_name] }}"
        identifier: "bulk_builder"
        state: present
      tags: workflow

    - name: Link workflow nodes (success paths)
      ansible.controller.workflow_job_template_node:
        controller_host: "{{ controller_host }}"
        controller_oauthtoken: "{{ _controller_token if _controller_token | length > 0 else omit }}"
        controller_username: "{{ _controller_username if (_controller_token | length == 0 and _controller_username | length > 0) else omit }}"
        controller_password: "{{ _controller_password if (_controller_token | length == 0 and _controller_password | length > 0) else omit }}"
        validate_certs: "{{ controller_verify_ssl }}"
        workflow_job_template: "{{ workflow_name }}"
        identifier: "{{ item.identifier }}"
        success_nodes: "{{ item.success_nodes }}"
        state: present
      loop:
        - { identifier: 'push_template', success_nodes: ['associate_os'] }
        - { identifier: 'associate_os', success_nodes: ['foreman_params'] }
        - { identifier: 'foreman_params', success_nodes: ['bulk_builder'] }
      tags: workflow

    - name: Display job template creation results
      ansible.builtin.debug:
        msg: |
          Job Template: {{ item.item.name }}
          Status: {{ 'Created/Updated' if not item.failed else 'FAILED' }}
          {% if item.failed %}
          Error: {{ item.msg | default('Unknown error') }}
          {% endif %}
      loop: "{{ _job_template_results.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      tags: job_templates

    - name: Count successful and failed templates
      ansible.builtin.set_fact:
        _successful_count: "{{ _job_template_results.results | rejectattr('failed') | list | length }}"
        _failed_count: "{{ _job_template_results.results | selectattr('failed') | list | length }}"
      tags: job_templates

    - name: Final summary
      ansible.builtin.debug:
        msg: |
          ========================================
          AAP Job Template Configuration Complete
          ========================================
          
          Controller: {{ controller_host }}
          Organization: {{ organization_name }}
          Project: {{ project_name }}
          Inventory: {{ inventory_name }}
          
          Results:
          - Successful: {{ _successful_count }}/{{ job_templates | length }}
          - Failed: {{ _failed_count }}/{{ job_templates | length }}
          
          Created/Updated Templates:
          {% for result in _job_template_results.results %}
          {% if not result.failed %}
          [SUCCESS] {{ result.item.name }}
          {% endif %}
          {% endfor %}
          
          {% if _failed_count | int > 0 %}
          Failed Templates:
          {% for result in _job_template_results.results %}
          {% if result.failed %}
          [FAILED] {{ result.item.name }}: {{ result.msg | default('Unknown error') }}
          {% endif %}
          {% endfor %}
          {% endif %}
          
          Next Steps:
          1. Log into AAP UI: {{ controller_host }}
          2. Navigate to Resources > Templates
          3. Test job templates with sample data
          4. Configure notifications and schedules
          
          Documentation:
          - See playbooks/README.md for detailed usage
          - AAP API docs: {{ controller_host }}/api/controller/v2/
      tags: always
